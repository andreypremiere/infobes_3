{"ast":null,"code":"/* global BigInt */\n\nimport bigInt from 'big-integer';\nimport CryptoJS from 'crypto-js';\n\n// Генерация числа b\nexport function generateRandomNumber(minExp = 1, maxExp = 50) {\n  const randomNumber = getRandomBigIntInRange(minExp, maxExp);\n\n  // console.log(\"Сгенерированное число:\", randomNumber.toString());\n\n  return randomNumber;\n}\n\n// Расчет числа B\nexport function calculateNumberB(g, b, p) {\n  const result = modPow(g, b, p);\n  return result;\n}\n\n// Расчет общего числа\nexport function calculateNumberS(A, b, p) {\n  const result = modPow(A, b, p);\n  return result;\n}\nexport async function deriveKey(sharedKey) {\n  // Преобразуем sharedKey (число) в ArrayBuffer\n  const sharedKeyBuffer = new Uint8Array(BigInt(sharedKey).toString(16).match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n\n  // Константы HKDF\n  const salt = new Uint8Array(); // Пустой Uint8Array для соли\n  const info = new TextEncoder().encode('diffie-hellman encryption'); // Информация для HKDF\n\n  // Импортируем sharedKey как ключ\n  const baseKey = await crypto.subtle.importKey('raw', sharedKeyBuffer, {\n    name: 'HKDF'\n  }, false, ['deriveBits', 'deriveKey']);\n\n  // Генерируем производный ключ\n  const derivedKey = await crypto.subtle.deriveKey({\n    name: 'HKDF',\n    hash: 'SHA-256',\n    salt: salt,\n    info: info\n  }, baseKey, {\n    name: 'AES-CBC',\n    length: 256\n  },\n  // Тип производного ключа\n  true, ['encrypt', 'decrypt']);\n\n  // Экспортируем ключ в формате ArrayBuffer\n  const rawKey = await crypto.subtle.exportKey('raw', derivedKey);\n\n  // Возвращаем ключ в виде массива байтов\n  return new Uint8Array(rawKey); // Исправлено: возвращаем Uint8Array\n}\nfunction uint8ArrayToWordArray(u8Array) {\n  const words = [];\n  for (let i = 0; i < u8Array.length; i += 4) {\n    words.push(u8Array[i] << 24 | u8Array[i + 1] << 16 | u8Array[i + 2] << 8 | u8Array[i + 3]);\n  }\n  return CryptoJS.lib.WordArray.create(words, u8Array.length);\n}\nfunction modPow(base, exponent, modulus) {\n  base = BigInt(base);\n  exponent = BigInt(exponent);\n  modulus = BigInt(modulus);\n  let result = 1n;\n  base = base % modulus;\n  while (exponent > 0n) {\n    if (exponent % 2n === 1n) {\n      result = result * base % modulus;\n    }\n    exponent = exponent >> 1n; // делим на 2\n    base = base * base % modulus;\n  }\n  return result;\n}\nfunction getRandomBigIntInRange(minExponent = 1, maxExponent = 50) {\n  // Преобразуем степени в числа типа BigInt\n  const min = BigInt(10 ** minExponent);\n  const max = BigInt(10 ** maxExponent);\n  if (min > max) {\n    throw new Error(\"Минимальное значение не может быть больше максимального.\");\n  }\n\n  // Диапазон\n  const range = max - min + BigInt(1);\n\n  // Генерация случайного числа в диапазоне\n  const rand = BigInt(Math.floor(Math.random() * Number(range))); // Ограничиваем `Math.random()` до диапазона\n  return min + rand;\n}\nexport async function deriveKeyPythonCompatible(sharedKey) {\n  // Преобразуем sharedKey (число) в ArrayBuffer так же, как в Python\n  const sharedKeyBuffer = BigInt(sharedKey).toString(16) // Преобразуем число в строку HEX\n  .padStart(sharedKey.length * 2, '0') // Дополняем до чётного количества символов\n  .match(/.{1,2}/g) // Разбиваем на пары символов\n  .map(byte => parseInt(byte, 16)); // Преобразуем в байты\n\n  // Конвертируем в Uint8Array\n  const sharedKeyArray = new Uint8Array(sharedKeyBuffer);\n\n  // Константы HKDF\n  const salt = null; // Нет соли, аналогично Python\n  const info = new TextEncoder().encode('diffie-hellman encryption'); // Информация для HKDF\n\n  // Импортируем sharedKey как ключ\n  const baseKey = await crypto.subtle.importKey('raw', sharedKeyArray, {\n    name: 'HKDF'\n  }, false, ['deriveBits', 'deriveKey']);\n\n  // Генерируем производный ключ\n  const derivedKey = await crypto.subtle.deriveKey({\n    name: 'HKDF',\n    hash: 'SHA-256',\n    salt: new Uint8Array(0),\n    // Пустая соль\n    info: info\n  }, baseKey, {\n    name: 'AES-CBC',\n    length: 256\n  },\n  // Тип производного ключа\n  true, ['encrypt', 'decrypt']);\n\n  // Экспортируем ключ в формате Uint8Array\n  const rawKey = await crypto.subtle.exportKey('raw', derivedKey);\n\n  // Возвращаем ключ в виде массива байтов\n  return new Uint8Array(rawKey);\n}","map":{"version":3,"names":["bigInt","CryptoJS","generateRandomNumber","minExp","maxExp","randomNumber","getRandomBigIntInRange","calculateNumberB","g","b","p","result","modPow","calculateNumberS","A","deriveKey","sharedKey","sharedKeyBuffer","Uint8Array","BigInt","toString","match","map","byte","parseInt","salt","info","TextEncoder","encode","baseKey","crypto","subtle","importKey","name","derivedKey","hash","length","rawKey","exportKey","uint8ArrayToWordArray","u8Array","words","i","push","lib","WordArray","create","base","exponent","modulus","minExponent","maxExponent","min","max","Error","range","rand","Math","floor","random","Number","deriveKeyPythonCompatible","padStart","sharedKeyArray"],"sources":["D:/учеба/3 курс/1 семестр/ИнфоБез/pracitce_3/practice_3_ui/src/numberTools.js"],"sourcesContent":["/* global BigInt */\r\n\r\nimport bigInt from 'big-integer';\r\nimport CryptoJS from 'crypto-js';\r\n\r\n\r\n// Генерация числа b\r\nexport function generateRandomNumber(minExp = 1, maxExp = 50) {\r\n    const randomNumber = getRandomBigIntInRange(minExp, maxExp)\r\n\r\n    // console.log(\"Сгенерированное число:\", randomNumber.toString());\r\n\r\n    return randomNumber;\r\n}\r\n\r\n// Расчет числа B\r\nexport function calculateNumberB(g, b, p) {\r\n\r\n    const result = modPow(g, b, p)\r\n    return result;\r\n}\r\n\r\n// Расчет общего числа\r\nexport function calculateNumberS(A, b, p) {\r\n\r\n    const result = modPow(A, b, p)\r\n    return result\r\n}\r\n\r\nexport async function deriveKey(sharedKey) {\r\n  // Преобразуем sharedKey (число) в ArrayBuffer\r\n  const sharedKeyBuffer = new Uint8Array(\r\n      BigInt(sharedKey).toString(16).match(/.{1,2}/g).map((byte) => parseInt(byte, 16))\r\n  );\r\n\r\n  // Константы HKDF\r\n  const salt = new Uint8Array(); // Пустой Uint8Array для соли\r\n  const info = new TextEncoder().encode('diffie-hellman encryption'); // Информация для HKDF\r\n\r\n  // Импортируем sharedKey как ключ\r\n  const baseKey = await crypto.subtle.importKey(\r\n      'raw',\r\n      sharedKeyBuffer,\r\n      { name: 'HKDF' },\r\n      false,\r\n      ['deriveBits', 'deriveKey']\r\n  );\r\n\r\n  // Генерируем производный ключ\r\n  const derivedKey = await crypto.subtle.deriveKey(\r\n      {\r\n          name: 'HKDF',\r\n          hash: 'SHA-256',\r\n          salt: salt,\r\n          info: info,\r\n      },\r\n      baseKey,\r\n      { name: 'AES-CBC', length: 256 }, // Тип производного ключа\r\n      true,\r\n      ['encrypt', 'decrypt']\r\n  );\r\n\r\n  // Экспортируем ключ в формате ArrayBuffer\r\n  const rawKey = await crypto.subtle.exportKey('raw', derivedKey);\r\n\r\n  // Возвращаем ключ в виде массива байтов\r\n  return new Uint8Array(rawKey); // Исправлено: возвращаем Uint8Array\r\n}\r\n\r\n  \r\n\r\n  function uint8ArrayToWordArray(u8Array) {\r\n    const words = [];\r\n    for (let i = 0; i < u8Array.length; i += 4) {\r\n        words.push(\r\n            (u8Array[i] << 24) |\r\n            (u8Array[i + 1] << 16) |\r\n            (u8Array[i + 2] << 8) |\r\n            u8Array[i + 3]\r\n        );\r\n    }\r\n    return CryptoJS.lib.WordArray.create(words, u8Array.length);\r\n}\r\n\r\nfunction modPow(base, exponent, modulus) {\r\n    base = BigInt(base);\r\n    exponent = BigInt(exponent);\r\n    modulus = BigInt(modulus);\r\n\r\n    let result = 1n;\r\n    base = base % modulus;\r\n\r\n    while (exponent > 0n) {\r\n        if (exponent % 2n === 1n) {\r\n            result = (result * base) % modulus;\r\n        }\r\n        exponent = exponent >> 1n; // делим на 2\r\n        base = (base * base) % modulus;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction getRandomBigIntInRange(minExponent = 1, maxExponent = 50) {\r\n    // Преобразуем степени в числа типа BigInt\r\n    const min = BigInt(10 ** minExponent);\r\n    const max = BigInt(10 ** maxExponent);\r\n  \r\n    if (min > max) {\r\n      throw new Error(\"Минимальное значение не может быть больше максимального.\");\r\n    }\r\n  \r\n    // Диапазон\r\n    const range = max - min + BigInt(1);\r\n  \r\n    // Генерация случайного числа в диапазоне\r\n    const rand = BigInt(Math.floor(Math.random() * Number(range))); // Ограничиваем `Math.random()` до диапазона\r\n    return min + rand;\r\n  }\r\n  \r\n  export async function deriveKeyPythonCompatible(sharedKey) {\r\n    // Преобразуем sharedKey (число) в ArrayBuffer так же, как в Python\r\n    const sharedKeyBuffer = BigInt(sharedKey)\r\n        .toString(16) // Преобразуем число в строку HEX\r\n        .padStart(sharedKey.length * 2, '0') // Дополняем до чётного количества символов\r\n        .match(/.{1,2}/g) // Разбиваем на пары символов\r\n        .map((byte) => parseInt(byte, 16)); // Преобразуем в байты\r\n\r\n    // Конвертируем в Uint8Array\r\n    const sharedKeyArray = new Uint8Array(sharedKeyBuffer);\r\n\r\n    // Константы HKDF\r\n    const salt = null; // Нет соли, аналогично Python\r\n    const info = new TextEncoder().encode('diffie-hellman encryption'); // Информация для HKDF\r\n\r\n    // Импортируем sharedKey как ключ\r\n    const baseKey = await crypto.subtle.importKey(\r\n        'raw',\r\n        sharedKeyArray,\r\n        { name: 'HKDF' },\r\n        false,\r\n        ['deriveBits', 'deriveKey']\r\n    );\r\n\r\n    // Генерируем производный ключ\r\n    const derivedKey = await crypto.subtle.deriveKey(\r\n        {\r\n            name: 'HKDF',\r\n            hash: 'SHA-256',\r\n            salt: new Uint8Array(0), // Пустая соль\r\n            info: info,\r\n        },\r\n        baseKey,\r\n        { name: 'AES-CBC', length: 256 }, // Тип производного ключа\r\n        true,\r\n        ['encrypt', 'decrypt']\r\n    );\r\n\r\n    // Экспортируем ключ в формате Uint8Array\r\n    const rawKey = await crypto.subtle.exportKey('raw', derivedKey);\r\n\r\n    // Возвращаем ключ в виде массива байтов\r\n    return new Uint8Array(rawKey);\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}